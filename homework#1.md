스터디할래 / 자바 스터디 과제 #1 JVM은 무엇이며 자바 코드는 어떻게 실행되는 것인가?

## 과제 키워드

- JVM이란 무엇인가
- 컴파일 하는 방법
- 실행하는 방법
- 바이트코드란 무엇인가
- JIT 컴파일러란 무엇이며 어떻게 동작하는지
- JVM 구성 요소
- JDK와 JRE의 차이


## JVM이란 무엇인가?

JVM은 Java Virtual Machine을 말하는 것으로 자바 코드 또는 어플리케이션을 실행할 수 있는 런타임환경을 제공하는 엔진을 말한다. JVM은 자바 바이트코드를 기계어로 번역해준다. JVM은 JRE(Java Run Environment)의 한 부분이다. 일반적으로 다른 프로그래밍 언어에서는 컴파일러가 특정한 시스템에 대한 기계어를 생성한다. 하지만, 자바 컴파일러는 JVM(Java Virtual Machine)으로 알려진 VM(Virtual Machine)에 대한 코드를 생성한다는 점이 좀 다르다.

### JVM이 동작하는 방식

먼저, 자바 코드가 바이트 코드로 컴파일된다. 이 바이트코드는 각기 다른 머신에서 인터프리팅을 거친다. 

호스트의 시스템과 자바 소스 사이에서, 바이트코드는 중간단계의 언어로서의 위치를 갖는다.

JVM은 자바에서 할당된 메모리 공간에 대한 책임을 갖는다.

![](https://images.velog.io/images/jakeseo_me/post/1dc04d07-1901-467e-ada0-514c01d371aa/Screen%20Shot%202020-12-31%20at%206.14.11%20PM.png)

### JVM 아키텍쳐

![](https://images.velog.io/images/jakeseo_me/post/749cf960-4dbb-4756-9004-3924110e899d/Screen%20Shot%202020-12-31%20at%206.21.18%20PM.png)

#### 1. 클래스 로더

클래스 로더는 클래스 파일들을 불러오는데 사용되는 서브시스템이다. 클래스 로더는 3가지 주 기능을 수행하는데, 로딩, 링킹, 초기화를 수행한다.

#### 2. 메소드 영역

JVM 메소드 영역은 메타 데이터, 상수 런타임 풀, 메소드에 대한 코드와 같은 것들에 대한 클래스 구조를 저장한다.

#### 3. 힙 영역

모든 오브젝트들, 관련된 인스턴스 변수들, 배열이 힙 영역에 저장된다. 힙 메모리는 여러 스레드 사이에서 공유된다.

#### 4. JVM 언어 스택

자바 언어 스택은 지역 변수들, 그리고 부분적인 결과들을 저장한다. 각 스레드는 스레드가 생성되는 것과 동시에 고유의 JVM 스택을 소유한다. 메소드가 호출될 때마다 새로운 프레임이 만들어지고 메소드 호출 프로세스가 완료될 때, 만들어졌던 프레임이 삭제된다.

#### 5. PC 레지스터

PC 레지스터는 현재 실행되는 JVM 명령의 주소를 저장한다. 자바에서는 각 스레드가 분리된 PC 레지스터를 갖는다. (공유되는 힙 영역과는 반대이다.)

#### 6. 네이티브 메소드 스택

네이티브 메소드 스택은 네이티브 라이브러리에 의존하는 네이티브 코드의 명령을 갖고 있는다. 이 부분은 자바 말고 다른 언어로 쓰여져 있다.

#### 7. 실행 엔진

하드웨어, 소프트웨어 또는 완전한 시스템을 테스트하기 위해서 사용된다. 테스트 실행 엔진은 테스트된 제품에 대한 어떤 정보도 가지고 오지 않는다.

#### 8. 네이티브 메소드 인터페이스

네이티브 메소드 인터페이스는 프로그래밍 프레임워크이다. JVM에서 실행중인 자바 코드가 라이브러리 및 네이티브 어플리케이션에 의해 호출되도록 한다.

#### 9. 네이티브 메소드 라이브러리

네이티브 라이브러리는 실행 엔진이 필요로 하는 네이티브 라이브러리들(C, C++)의 콜렉션이다.

### 소프트웨어 코드 컴파일과 실행 프로세스

#### 1. 에디터

IDE를 통한 코드 입력이 된다.

#### 2. 컴파일러

고수준 언어의 프로그램을 네이티브 기계 코드로 변환한다.

#### 3. 링커

메인 프로그램에서 다른 프로그램 파일 참조들을 모은다.

#### 4. 로더

실행을 위해 하드디스크, 플래시 드라이브, CD와 같은 2차적인 저장소에서 파일들을 불러서 RAM에 넣는다. 우리의 코드가 동작할 때 이 로더의 loading은 자동적으로 완료된다.

#### 5. 실행

OS 혹은 프로세서에 의해 다뤄지는 코드의 실제적인 실행 부분이다.

### C코드에서의 컴파일과 실행

자바와 비교해보기 위해 C의 컴파일과 링킹에 대해 간단히 알아보자. 

`f1`과 `f2`라는 함수를 메인함수에서 불러왔다고 가정해보자. 또한 그 메인 함수는 파일 `a1.c`에 있다고 치자.

![](https://images.velog.io/images/jakeseo_me/post/e1342b3b-0b9b-4b2c-9b4f-9f0a447b171e/Screen%20Shot%202021-01-01%20at%2012.43.25%20AM.png)

`f1`과 `f2`함수는 각각 `a2.c` 파일과 `a3.c` 파일에 나눠져있다.

![](https://images.velog.io/images/jakeseo_me/post/9eead52f-0b81-429f-b89e-8ab1c4ac5655/Screen%20Shot%202021-01-01%20at%2012.46.05%20AM.png)

이 상황에서 `a1.c`, `a2.c`, `a3.c` 파일은 컴파일러에 먹여진다. 컴파일러는 머신 코드의 오브젝트 파일들을 출력한다.

![](https://images.velog.io/images/jakeseo_me/post/05061bb3-ddf6-4759-a2e1-ea2b639508a9/Screen%20Shot%202021-01-01%20at%2012.51.38%20AM.png)

다음 단계는 링커의 도움을 받아서 모든 오브젝트 파일을 하나의 `single.exe` 파일로 만든다. 링커는 해당 파일들을 묶고 `.exe` 파일을 생성한다.

![](https://images.velog.io/images/jakeseo_me/post/8d30c232-545d-4bca-a423-8c93287a9b14/Screen%20Shot%202021-01-01%20at%2012.56.08%20AM.png)

프로그램 실행 동안에 로더 프로그램은 실행을 위해 a.exe를 RAM으로 로드한다.

![](https://images.velog.io/images/jakeseo_me/post/ffe94ada-e62a-40cd-831a-9908dafb8707/Screen%20Shot%202021-01-01%20at%2012.57.58%20AM.png)

### JVM에서의 자바 코드 컴파일과 실행 

이전과 똑같이 `f1`과 `f2` 함수가 각각 다른 파일에 있다고 가정하자.

- 메인 메소드는 `a1.java` 파일에 저장되어 있다.
- `f1`은 `a2.java`에 저장되어 있다.
- `f2`는 `a3.java`에 저장되어 있다.

![](https://images.velog.io/images/jakeseo_me/post/910fd6e4-7756-4037-9531-c9689f1cbef5/Screen%20Shot%202021-01-01%20at%201.01.26%20AM.png)

> C에서의 컴파일, 실행과 비교해보면?
> - 링킹 과정이 없다.
> - 클래스 파일들은 바이트 코드를 포함한다.

컴파일러는 3개의 파일을 받아서 바이트코드가 들어있는 3개의 클래스를 배출해낸다. **C와 달리 링킹 과정은 없다.**

JVM은 램에 상주한다. 실행하는 동안, 클래스 로더에 의해 클래스 파일들이 램으로 올라온다. 바이트 코드는 보안 위반에 대해서 검증이 된다.

![](https://images.velog.io/images/jakeseo_me/post/5c193c40-2812-4ba3-92d5-ff2692f052c7/Screen%20Shot%202021-01-01%20at%201.06.31%20AM.png)

다음으로 실행 엔진이 바이트 코드를 네이티브 머신 코드로 바꿀 것이다. 이러한 행위를 Just In Time 컴파일링이라고 한다. 이게 자바가 왜 상대적으로 느린지에 대한 주된 이유이다.

![](https://images.velog.io/images/jakeseo_me/post/6631013a-3130-4225-b2fd-7c45036ba137/Screen%20Shot%202021-01-01%20at%201.10.15%20AM.png)

> **참고: JIT** 혹은 just-in-time 컴파일러는 JVM의 한 부분이다. 동시에 비슷한 기능을 가지고 있는 바이트코드의 일부를 해석(인터프리팅)한다.

### 왜 자바는 해석도 되고 컴파일도 되어야 하는 언어인가?

프로그래밍 언어는 다음과 같이 분류된다.

- 더 고수준의 언어 ex) C++, JAVA
- 중간 수준의 언어 ex) C
- 저수준의 언어 ex) 어셈블리
- 기계어처럼 최고로 낮은 수준의 언어

**컴파일러**는 언어를 한 수준에서 더 낮은 수준으로 변화시키는 프로그램이다. 예를들면 C++ 프로그램이 기계어로 변화된다.

자바 컴파일러는 자바 코드를 바이트 코드로 변화시킨다. (바이트 코드 역시 기계어의 한 종류이다.)

**인터프리터**는 어떤 한 단계에서 **같은 단계**의 다른 프로그래밍 언어로 프로그램을 변화시킨다. 예를 들면 자바 코드를 C++ 코드로 변화시킨다.

자바에서, JIT 코드 생성기는 바이트 코드를 같은 프로그래밍 단계의 네이티브 기계어 코드로 바꾼다.

정리해보면 자바는 컴파일러에 의해서 바이트 코드로 바뀐 뒤에 또 JIT 코드 생성기에 의해서 네이티브 기계어 코드로 변화해야 한다.

### 왜 자바는 느린가?

자바가 느린 이유에는 다음과 같은 밑바탕이 있다.

- **동적인 링크** : C와는 다르게, 매번 자바 프로그램을 실행시키는 런타임에 링킹이 완료된다.
- **런타임 인터프리팅** : 바이트 코드에서 네이티브 기계어 코드로의 변환이 자바 런타임에 완료된다. 이 과정 때문에 자바가 더 느려진다.

하지만, 최신 버전의 자바는 성능 병목현상을 상당부분 해결했다.

### 요약

- JVM은 자바 코드를 실행시켜주는 엔진이다. JVM은 자바의 바이트코드를 기계어로 바꾸어준다. (컴파일러가 자바 코드를 바이트 코드로 바꾸고 그것을 JVM이 네이티브 기계어로 변경해준다.)
- JVM 아키텍쳐는 클래스 로더, 메모리 영역, 실행 엔진을 포함한다.
- JVM에서 자바 코드는 바이트 코드로 컴파일된다. 바이트코드는 다른 머신 위에서 인터프리팅된다.
- JIT는 Just-in-time 컴파일러를 말한다. JIT은 JVM의 한 부분이다. JIT는 실행 시간을 빠르게 만들게 하기 위해서 사용된다.
- 다른 컴파일 머신과 비교했을 때, JVM은 실행이 약간 느릴 수 있다.

## 컴파일 하는 방법

컴파일을 한다는 것은 위의 JVM 설명에도 나왔듯이, 자바 코드가 들어있는 `.java` 파일을 바이트 코드가 들어있는 파일인 `.class` 파일로 바꾸는 것이다. 또 이 바이트 코드는 나중에 JIT를 통해 네이티브 기계 코드로 변환되어 실행된다.

> 먼저 컴파일이라는 것은 자바만 하는 것이 아니라 저수준의 언어를 제외한 대부분의 언어가 컴파일 과정을 거친다.

### 어휘 분석

컴파일러의 첫번째 단계로 이 단계에서는 단어들을 그룹화해서 소스 프로그램을 `어휘소(lexeme)` 혹은 `어휘 항목(lexeme)` 이라 불리는 의미있는 순서들로 만든다. 소스코드를 정규 문법에 따라 토큰의 집합으로 변환하는 어휘 분석 및 스캐닝이다. (어휘 분석은 스캐닝이라고도 불린다.)

이를테면 '홍', '길', '동', '은', '사', '람' 이라는 소스코드가 있다고 가정하면 '홍길동' 이라는 의미 있는 조각을 `어휘 항목(lexeme)`이라 할 수 있다.

`어휘소`, `어휘항목`은 `정수`, `식별자`와 같은 어떠한 토큰 이름을 갖는 토큰 클래스에 속한다. 어휘 분석기가 출력하는 토큰은 토큰 이름과 속성값으로 구성된다. <토큰 이름, 속성 값> 과 같은 구조를 갖는다. 

```javascript
a = b + c
```

위와 같은 코드가 있다고 가정했을 때, `a`라는 문자열은 `<id, 1>` 이라는 토큰으로 매핑되는 어휘항목이 될 수 있다. `id`는 토큰 이름으로 식별자를 의미하는 추상기호이며, 속성값 `1`은 심볼 내에서 해당 토큰의 위치를 가리킨다. 토큰 이름이나 속성 값은 컴파일러 설계자에 따라 달라질 수 있다. `=`라는 문자열은 토큰 `<assign, NULL>`로 매핑되며, 연산자 `=`을 가리키는 `assign`이라는 추상 기호를 토큰 이름으로 갖고, 심볼 테이블에 입력될 필요가 없기 때문에 속성 값은 `NULL`을 갖는다. 어휘 분석기가 위의 코드를 모두 토큰으로 매핑하면 아래와 같은 토큰 스트림이 생기게 된다.

`<id, 1>`, `<assign, NULL>`, `<id, 2>`, `<plus, NULL>`, `<id, 3>`

### 구문 분석

어휘분석기의 결과는 토큰들의 문법적 구조를 보여주는 표현을 생성하는데 사용된다. 구문분석은 파싱이라고도 한다. 어휘 분석기에서 출력한 토큰들을 이용하여 소스코드의 문법 구조를 서술하는 구문 트리(syntax tree)를 생성한다. 구문 트리는 어휘 분석기에서 생성한 토큰들을 갖는 노드 트리로서, 토큰 간의 우선순위 및 토큰간의 결합 관계 등과 같은 속성을 나타낸다. **구문 분석의 목적은 토큰 간의 관계가 올바르게 생성되었는지를 검사하는 것이다.** 영어 문장으로 예를 들었을 때 `"I is a student"`라는 문장이 어휘분석되면 `<1인칭 주어, NULL>`, `<3인칭 단수 동사, NULL>`이라는 토큰을 만들어낼 수 있고, 1인칭 주어에 3인칭 단수 동사가 쓰인 것이 잘못됐다고 구문 에러를 출력할 수 있다. 소스 코드에 잘못된 토큰 간의 관계가 있는지 검사하는 것이 구문 분석의 목적이다.

```javascript
a = b + c
```

위와 같은 코드가 있을 때, 

![](https://images.velog.io/images/jakeseo_me/post/1f9ec244-2592-472f-b541-1a797a5fa4b8/Screen%20Shot%202021-01-01%20at%202.05.59%20AM.png)

위 그림처럼 구문 트리가 생성될 수 있다.

### 의미 분석

의미분석은 컴파일러 프론트 엔드의 마지막 단계이다. 컴파일러는 의미 규칙들을 파서에 의해 구축된 구문 트리에 적용한다. 이 단계에서 작업들은 컴파일러의 설계에 따라 다르지만, 일반적으로 형 검사, 범위 검사 그리고 객체 바인딩을 포함한다. 코드 생성을 위한 준비에서 심볼 테이블들 또한 구문 분석 때 만들어진다. 몇몇 경우들에서 의미 분석은 구문 분석과 함께 수행된다.

의미 분석 단계에서는 구문 트리와 심볼 테이블에 있는 정보를 이용하여 소스코드가 언어 정의에 의미적으로 부합하는지를 검사한다. 의미 분석의 중요한 기능은 타입 검사이다. 컴파일러는 타입 검사를 수행하면서 피연산자가 연산자에 부합하는지를 검사한다. **의미 분석기는 정수와 문자열의 덧셈, 값을 0으로 나누는 행동 등과 같이 의미적으로 올바르지 않은 코드의 존재 유무를 검사한다.** 이를테면 "The earth revolves around the moon"이라는 문장이 있을 때, 이 문장의 문법은 정확하지만, "지구가 달 주변을 회전한다"는 의미는 틀렸으므로, 의미분석에서 걸리게 된다.

의미 분석의 어려운 점은 의미분석이라는 연산이 수학적으로 완벽하지 않다는 것 때문에 발생한다. "지구가 달 주변을 회전한다" 라는 문장이 소설과 같은 곳에서 등장했다면 마냥 틀린 문장이 아닐 것이다. 어휘분석이나 구문분석과는 다르게 수학적으로 일정한 규칙을 갖지 않고, 의미를 해석한다는 연산 자체에 모호한 부분이 있기 때문에 의미 분석에는 많은 어려움이 존재한다. 이전의 어휘 분석기나 구문 분석기는 독립적으로 실행되어 출력을 만들어냈지만, 의미 분석기는 이러한 난해함 때문에 이전 단계에서 생성한 구문 트리와 심볼 테이블을 참조하며 의미 분석을 수행해야 한다.

### 코드 생성

자바는 이 과정에서 `.class` 바이트코드가 생성된다. 그리고 그 이후에 `.class` 파일이 `JVM` 내부에 있는 `JIT`에 의해 기계어 네이티브 코드로 변환된다.

> 상용 컴파일러에서는 의미 분석 단계와 코드 생성 단계 중간에 코드 최적화 단계가 추가되는데, 코드 최적화 단계는 해당 언어의 성능이나 자원 소모를 결정짓는 중요한 단계이다. 그러나 코드 최적화 단계는 컴파일러보다는 컴퓨터 구조에 대한 지식을 요구하는 단계이다.

## 실행하는 방법

- 사용자가 `.java` 확장자의 자바 소스코드를 작성해두었다.
- 컴파일러는 `.java` 파일을 읽어들여 기계어와 가까운 코드인 `바이트코드`로 변경한다.
- `바이트코드`로 변경되며 `.java` 파일은 `.class` 파일이 된다. 
- `.class` 파일들은 JVM의 클래스 로더에 의해 램 위로 올라온다.
- 램 위로 올라온 `.class` 파일들은 `바이트코드 검증기`에 의해 검증된다.
- 이후 `JIT 코드 생성기`에 의해 네이티브 기계 코드로 바뀐다.
- 네이티브 기계 코드로 바뀐 뒤에 실행 엔진에 의해 실행된다.


## 바이트코드란?

**자바 바이트코드** 는 자바 가상 머신이 실행하는 명령어의 형태이다. 각각의 바이트 코드는 1바이트로 구성되지만 몇 개의 파라미터가 사용되는 경우가 있어서 총 몇 바이트로 구성되는 경우도 있다. 256개의 명령코드 모두가 사용되지는 않는다.

> 바이트코드 관련 강의 : https://www.jrebel.com/blog/java-bytecode-tutorial

### 자바와의 관계

자바 프로그래머가 자바 바이트코드를 꼭 인지하거나 이해할 필요는 없다. 그렇지만 자바 프로그래머가 자바 컴파일러에 의해 바이트 코드가 어떻게 생성될 것인지를 이해하는 것은 C, C++ 프로그래머가 어셈블리어를 이애하는 것과 같다고 한다.

### 역 컴파일러

이렇게 기계가 직접 실행하는 기계어가 아닌 중간단계인 바이트코드 형태로 변환되는 자바와 같은 언어는 바이트코드를 기반으로 소스코드를 역으로 추출해주는 역컴파일러 혹은 디컴파일러에 취약한 편이다. 

이에 대한 대비로 디컴파일을 어렵게 하고, 만일 성공하더라도 원래의 소스 구조를 알기 힘들게 변경하는 프로그램들이 존재한다. 이 프로그램들은 주로 클래스 파일의 디버깅 정보를 제거하고 클래스명/함수명/변수명 등을 임의의 단문자 형태로 치환하기 때문에 생성되는 클래스 파일의 크기를 줄이는 목적으로도 활용된다.

### 바이트코드의 예

![](https://images.velog.io/images/jakeseo_me/post/e9823998-2d75-4007-a6be-cb029aff17dd/Screen%20Shot%202021-01-01%20at%202.26.22%20AM.png)

> 출처: [위키백과](https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C)

## JIT 컴파일러란 무엇이며 어떻게 동작하는지

JIT 컴파일러는 런타임에 자바 어플리케이션의 성능을 향상시키는 JRE의 컴포넌트이다.  JVM에 있는 것중 그 어느것도 컴파일러보다 더 성능에 영향을 미치진 않는다. 그리고 자바 어플리케이션을 수행할 때 컴파일러를 고르는 것은 가장 첫 결정이 된다. 이건 여러분이 자바 개발자이건, 자바 사용자이건 상관없다.

### JIT 의 동작 방식

자바 프로그램에는 많은 다른 컴퓨터 아키텍쳐들 위에서 JVM에 의해 번역될 수 있는 플랫폼에 중립적인 바이트코드를 갖고 있는 클래스가 포함되어 있다. 런타임에, JVM은 클래스 파일들을 불러오고, 각 바이트 코드의 의미를 결정한다 그리고 올바른 컴퓨테이션을 수행한다. 번역 중에 추가적인 프로세서, 메모리 사용은 자바 어플리케이션이 네이티브 어플리케이션보다 조금 더 느리게 동작하게 만든다. JIT 컴파일러는 런타임에 바이트코드를 네이티브 기계어 코드로 컴파일링함으로써 자바 프로그램의 퍼포먼스를 증가시키는데 도움을 준다.

JIT 컴파일러는 기본값으로 동작 가능하게 설정되어있고, 자바 메소드가 호출되었을 때 활성화된다. JIT 컴파일러는 메소드의 바이트코드를 컴파일하여 네이티브 기계어 코드로 만든다. 메소드가 컴파일 될 때, JVM은 직접 메소드를 인터프리팅하기보다 컴파일된 코드를 호출한다. 이론상으로, 만일 컴파일이 프로세서 시간과 메모리 사용을 요구하지 않는다면, 모든 메소드를 컴파일하는 것이 네이티브 어플리케이션의 그것에 근접하는 속도를 가능하게 만들어줄 것이다.

## JVM 구성 요소

![](https://images.velog.io/images/jakeseo_me/post/695b2f8c-6d9d-4367-afb7-3b4521fabb86/Screen%20Shot%202021-01-01%20at%202.47.26%20AM.png)

대략 위와 같은 구조로 되어있다.

### 클래스 로더

JVM의 서브시스템으로 클래스 파일을 불러온다. 자바 프로그램을 실행시키면 클래스 로더가 가장 먼저 클래스들을 불러온다.

### 클래스 메소드 영역

JVM 안의 데이터 영역 중 하나다. 클래스 데이터가 여기에 저장된다. Static 변수, Static 블록, Static 메소드들이 여깄다. 인스턴스 메소드들도 이 영역에 저장된다.

### 힙 영역

힙 영역은 JVM이 시작될 때 만들어진다. 어플리케이션이 실행되면서 힙 영역은 늘었다 줄었다할 수 있다.

### 스택

JVM 스택은 스레드 스택이라고 알려져있다. JVM 메모리의 데이터 영역이다. 단일 실행 스레드를 위해 만들어져있다. 스레드의 JVM 스택은 여러가지 요소들을 저장하기 위해서 스레드에 의해 사용된다. 이를테면 로컬 변수, 부분적인 결과들, 메소드를 호출하고 반환하기 위한 데이터들...

### 네이티브 스택

앱에서 사용된 모든 네이티브 메소드들을 포함한다.

### 실행 엔진

- JIT 컴파일러
- 가비지 콜렉터
  - JVM 힙 영역에 있는 모든 오브젝트를 추적하며 사용되지 않는 오브젝트들을 제거한다. 가비지 콜렉터는 `Mark`와 `Sweep`이라는 간단한 2단계를 통해 움직인다.
    - `Mark` : 가비지 콜렉터는 해당 메모리가 사용되는지 아닌지 기록한다.
    - `Sweep` : `Mark`에서 사용되지 않는다고 기록된 오브젝트를 지운다.

## JDK와 JRE의 차이

### JRE

JRE는 자바프로그램들이 실행될 수 있는 런타임 환경을 빌드하는 소프트웨어이다. JRE는 자바 코드를 받고, 필요로 하는 라이브러리들과 합쳐서 JVM을 이용해 실행시키는 `on-disk` 시스템이다. JRE는 자바 프로그램을 실행시키기 위해서 필요한 라이브러리들과 소프트웨어들을 포함한다. JRE는 JDK의 일부이다. 

### JDK

JDK는 자바 어플리케이션과 applets를 개발하기 위한 소프트웨어 개발 환경이다. JRE와 몇가지 개발 도구들, 인터프리터/로더(`java`), 컴파일러(`javac`), 압축유틸(`jar`) `javadoc`에 의해 생성된 문서들을 포함한다.
