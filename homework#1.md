스터디할래 / 자바 스터디 과제 #1 JVM은 무엇이며 자바 코드는 어떻게 실행되는 것인가?

## 과제 키워드

- JVM이란 무엇인가
- 컴파일 하는 방법
- 실행하는 방법
- 바이트코드란 무엇인가
- JIT 컴파일러란 무엇이며 어떻게 동작하는지
- JVM 구성 요소
- JDK와 JRE의 차이


## JVM이란 무엇인가?

JVM은 Java Virtual Machine을 말하는 것으로 자바 코드 또는 어플리케이션을 실행할 수 있는 런타임환경을 제공하는 엔진을 말한다. JVM은 자바 바이트코드를 기계어로 번역해준다. JVM은 JRE(Java Run Environment)의 한 부분이다. 일반적으로 다른 프로그래밍 언어에서는 컴파일러가 특정한 시스템에 대한 기계어를 생성한다. 하지만, 자바 컴파일러는 JVM(Java Virtual Machine)으로 알려진 VM(Virtual Machine)에 대한 코드를 생성한다는 점이 좀 다르다.

### JVM이 동작하는 방식

먼저, 자바 코드가 바이트 코드로 컴파일된다. 이 바이트코드는 각기 다른 머신에서 인터프리팅을 거친다. 

호스트의 시스템과 자바 소스 사이에서, 바이트코드는 중간단계의 언어로서의 위치를 갖는다.

JVM은 자바에서 할당된 메모리 공간에 대한 책임을 갖는다.

![](https://images.velog.io/images/jakeseo_me/post/1dc04d07-1901-467e-ada0-514c01d371aa/Screen%20Shot%202020-12-31%20at%206.14.11%20PM.png)

### JVM 아키텍쳐

![](https://images.velog.io/images/jakeseo_me/post/749cf960-4dbb-4756-9004-3924110e899d/Screen%20Shot%202020-12-31%20at%206.21.18%20PM.png)

#### 1. 클래스 로더

클래스 로더는 클래스 파일들을 불러오는데 사용되는 서브시스템이다. 클래스 로더는 3가지 주 기능을 수행하는데, 로딩, 링킹, 초기화를 수행한다.

#### 2. 메소드 영역

JVM 메소드 영역은 메타 데이터, 상수 런타임 풀, 메소드에 대한 코드와 같은 것들에 대한 클래스 구조를 저장한다.

#### 3. 힙 영역

모든 오브젝트들, 관련된 인스턴스 변수들, 배열이 힙 영역에 저장된다. 힙 메모리는 여러 스레드 사이에서 공유된다.

#### 4. JVM 언어 스택

자바 언어 스택은 지역 변수들, 그리고 부분적인 결과들을 저장한다. 각 스레드는 스레드가 생성되는 것과 동시에 고유의 JVM 스택을 소유한다. 메소드가 호출될 때마다 새로운 프레임이 만들어지고 메소드 호출 프로세스가 완료될 때, 만들어졌던 프레임이 삭제된다.

#### 5. PC 레지스터

PC 레지스터는 현재 실행되는 JVM 명령의 주소를 저장한다. 자바에서는 각 스레드가 분리된 PC 레지스터를 갖는다. (공유되는 힙 영역과는 반대이다.)

#### 6. 네이티브 메소드 스택

네이티브 메소드 스택은 네이티브 라이브러리에 의존하는 네이티브 코드의 명령을 갖고 있는다. 이 부분은 자바 말고 다른 언어로 쓰여져 있다.

#### 7. 실행 엔진

하드웨어, 소프트웨어 또는 완전한 시스템을 테스트하기 위해서 사용된다. 테스트 실행 엔진은 테스트된 제품에 대한 어떤 정보도 가지고 오지 않는다.

#### 8. 네이티브 메소드 인터페이스

네이티브 메소드 인터페이스는 프로그래밍 프레임워크이다. JVM에서 실행중인 자바 코드가 라이브러리 및 네이티브 어플리케이션에 의해 호출되도록 한다.

#### 9. 네이티브 메소드 라이브러리

네이티브 라이브러리는 실행 엔진이 필요로 하는 네이티브 라이브러리들(C, C++)의 콜렉션이다.

### 소프트웨어 코드 컴파일과 실행 프로세스

#### 1. 에디터

IDE를 통한 코드 입력이 된다.

#### 2. 컴파일러

고수준 언어의 프로그램을 네이티브 기계 코드로 변환한다.

#### 3. 링커

메인 프로그램에서 다른 프로그램 파일 참조들을 모은다.

#### 4. 로더

실행을 위해 하드디스크, 플래시 드라이브, CD와 같은 2차적인 저장소에서 파일들을 불러서 RAM에 넣는다. 우리의 코드가 동작할 때 이 로더의 loading은 자동적으로 완료된다.

#### 5. 실행

OS 혹은 프로세서에 의해 다뤄지는 코드의 실제적인 실행 부분이다.

### C코드에서의 컴파일과 실행

자바와 비교해보기 위해 C의 컴파일과 링킹에 대해 간단히 알아보자. 

`f1`과 `f2`라는 함수를 메인함수에서 불러왔다고 가정해보자. 또한 그 메인 함수는 파일 `a1.c`에 있다고 치자.

![](https://images.velog.io/images/jakeseo_me/post/e1342b3b-0b9b-4b2c-9b4f-9f0a447b171e/Screen%20Shot%202021-01-01%20at%2012.43.25%20AM.png)

`f1`과 `f2`함수는 각각 `a2.c` 파일과 `a3.c` 파일에 나눠져있다.

![](https://images.velog.io/images/jakeseo_me/post/9eead52f-0b81-429f-b89e-8ab1c4ac5655/Screen%20Shot%202021-01-01%20at%2012.46.05%20AM.png)

이 상황에서 `a1.c`, `a2.c`, `a3.c` 파일은 컴파일러에 먹여진다. 컴파일러는 머신 코드의 오브젝트 파일들을 출력한다.

![](https://images.velog.io/images/jakeseo_me/post/05061bb3-ddf6-4759-a2e1-ea2b639508a9/Screen%20Shot%202021-01-01%20at%2012.51.38%20AM.png)

다음 단계는 링커의 도움을 받아서 모든 오브젝트 파일을 하나의 `single.exe` 파일로 만든다. 링커는 해당 파일들을 묶고 `.exe` 파일을 생성한다.

![](https://images.velog.io/images/jakeseo_me/post/8d30c232-545d-4bca-a423-8c93287a9b14/Screen%20Shot%202021-01-01%20at%2012.56.08%20AM.png)

프로그램 실행 동안에 로더 프로그램은 실행을 위해 a.exe를 RAM으로 로드한다.

![](https://images.velog.io/images/jakeseo_me/post/ffe94ada-e62a-40cd-831a-9908dafb8707/Screen%20Shot%202021-01-01%20at%2012.57.58%20AM.png)

### JVM에서의 자바 코드 컴파일과 실행 

이전과 똑같이 `f1`과 `f2` 함수가 각각 다른 파일에 있다고 가정하자.

- 메인 메소드는 `a1.java` 파일에 저장되어 있다.
- `f1`은 `a2.java`에 저장되어 있다.
- `f2`는 `a3.java`에 저장되어 있다.

![](https://images.velog.io/images/jakeseo_me/post/910fd6e4-7756-4037-9531-c9689f1cbef5/Screen%20Shot%202021-01-01%20at%201.01.26%20AM.png)

> C에서의 컴파일, 실행과 비교해보면?
> - 링킹 과정이 없다.
> - 클래스 파일들은 바이트 코드를 포함한다.

컴파일러는 3개의 파일을 받아서 바이트코드가 들어있는 3개의 클래스를 배출해낸다. **C와 달리 링킹 과정은 없다.**

JVM은 램에 상주한다. 실행하는 동안, 클래스 로더에 의해 클래스 파일들이 램으로 올라온다. 바이트 코드는 보안 위반에 대해서 검증이 된다.

![](https://images.velog.io/images/jakeseo_me/post/5c193c40-2812-4ba3-92d5-ff2692f052c7/Screen%20Shot%202021-01-01%20at%201.06.31%20AM.png)

다음으로 실행 엔진이 바이트 코드를 네이티브 머신 코드로 바꿀 것이다. 이러한 행위를 Just In Time 컴파일링이라고 한다. 이게 자바가 왜 상대적으로 느린지에 대한 주된 이유이다.

![](https://images.velog.io/images/jakeseo_me/post/6631013a-3130-4225-b2fd-7c45036ba137/Screen%20Shot%202021-01-01%20at%201.10.15%20AM.png)

> **참고: JIT** 혹은 just-in-time 컴파일러는 JVM의 한 부분이다. 동시에 비슷한 기능을 가지고 있는 바이트코드의 일부를 해석(인터프리팅)한다.

### 왜 자바는 해석도 되고 컴파일도 되어야 하는 언어인가?

프로그래밍 언어는 다음과 같이 분류된다.

- 더 고수준의 언어 ex) C++, JAVA
- 중간 수준의 언어 ex) C
- 저수준의 언어 ex) 어셈블리
- 기계어처럼 최고로 낮은 수준의 언어

**컴파일러**는 언어를 한 수준에서 더 낮은 수준으로 변화시키는 프로그램이다. 예를들면 C++ 프로그램이 기계어로 변화된다.

자바 컴파일러는 자바 코드를 바이트 코드로 변화시킨다. (바이트 코드 역시 기계어의 한 종류이다.)

**인터프리터**는 어떤 한 단계에서 **같은 단계**의 다른 프로그래밍 언어로 프로그램을 변화시킨다. 예를 들면 자바 코드를 C++ 코드로 변화시킨다.

자바에서, JIT 코드 생성기는 바이트 코드를 같은 프로그래밍 단계의 네이티브 기계어 코드로 바꾼다.

정리해보면 자바는 컴파일러에 의해서 바이트 코드로 바뀐 뒤에 또 JIT 코드 생성기에 의해서 네이티브 기계어 코드로 변화해야 한다.

### 왜 자바는 느린가?

자바가 느린 이유에는 다음과 같은 밑바탕이 있다.

- **동적인 링크** : C와는 다르게, 매번 자바 프로그램을 실행시키는 런타임에 링킹이 완료된다.
- **런타임 인터프리팅** : 바이트 코드에서 네이티브 기계어 코드로의 변환이 자바 런타임에 완료된다. 이 과정 때문에 자바가 더 느려진다.

하지만, 최신 버전의 자바는 성능 병목현상을 상당부분 해결했다.

### 요약

- JVM은 자바 코드를 실행시켜주는 엔진이다. JVM은 자바의 바이트코드를 기계어로 바꾸어준다. (컴파일러가 자바 코드를 바이트 코드로 바꾸고 그것을 JVM이 네이티브 기계어로 변경해준다.)
- JVM 아키텍쳐는 클래스 로더, 메모리 영역, 실행 엔진을 포함한다.
- JVM에서 자바 코드는 바이트 코드로 컴파일된다. 바이트코드는 다른 머신 위에서 인터프리팅된다.
- JIT는 Just-in-time 컴파일러를 말한다. JIT은 JVM의 한 부분이다. JIT는 실행 시간을 빠르게 만들게 하기 위해서 사용된다.
- 다른 컴파일 머신과 비교했을 때, JVM은 실행이 약간 느릴 수 있다.
